# åœ¨ app.py çš„é¡¶éƒ¨æ·»åŠ (åœ¨ç°æœ‰importè¯­å¥åé¢)
from flask import jsonify
import sys
import os

# ========== æ€§èƒ½ä¼˜åŒ– ==========
# ç¦ç”¨è°ƒè¯•æ¨¡å¼
import flask
flask.cli.show_server_banner = lambda *args: None

# å‡å°‘æ—¥å¿—è¾“å‡º
import logging
logging.getLogger('werkzeug').setLevel(logging.ERROR)

# é™åˆ¶æ•°æ®åº“è¿æ¥
import sqlite3
import atexit

# è¿æ¥æ± ç®¡ç†
_db_connections = {}

def get_db_connection():
    """è·å–æ•°æ®åº“è¿æ¥(å¸¦è¿æ¥æ± )"""
    import threading
    thread_id = threading.get_ident()

    if thread_id not in _db_connections:
        _db_connections[thread_id] = sqlite3.connect(
            DB_PATH,
            timeout=10,
            check_same_thread=False
        )
        _db_connections[thread_id].row_factory = sqlite3.Row

    return _db_connections[thread_id]

def close_db_connections():
    """å…³é—­æ‰€æœ‰æ•°æ®åº“è¿æ¥"""
    for conn in _db_connections.values():
        try:
            conn.close()
        except:
            pass
    _db_connections.clear()

atexit.register(close_db_connections)

# ========== åŸæ¥çš„ä»£ç ç»§ç»­... ==========
from flask import Flask, render_template, request, jsonify, send_file, send_from_directory
import sqlite3
import os
import csv
import json
import time
import pandas as pd
import numpy as np
from datetime import datetime
import io
import hashlib
from functools import lru_cache

# ========== åº”ç”¨é…ç½® ==========
app = Flask(__name__, static_folder="static", template_folder="templates")
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB
app.config['SECRET_KEY'] = 'mouxu-lol-site-2024-secret'

# PythonAnywhereè·¯å¾„é…ç½®
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, 'instance', 'lol_data.db')
UPLOAD_FOLDER = os.path.join(BASE_DIR, 'uploads')

# ç¡®ä¿ç›®å½•å­˜åœ¨
os.makedirs(os.path.join(BASE_DIR, 'instance'), exist_ok=True)
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# ========== æ•°æ®åº“åˆå§‹åŒ– ==========
def init_database():
    """åˆå§‹åŒ–æ•°æ®åº“"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # è£…å¤‡è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        item_id INTEGER,
        name TEXT NOT NULL,
        gold_total INTEGER DEFAULT 0,
        gold_sell INTEGER DEFAULT 0,
        ad REAL DEFAULT 0,
        as_ REAL DEFAULT 0,
        crit REAL DEFAULT 0,
        ls REAL DEFAULT 0,
        apen REAL DEFAULT 0,
        ap REAL DEFAULT 0,
        ah REAL DEFAULT 0,
        mana REAL DEFAULT 0,
        mp5 REAL DEFAULT 0,
        hsp REAL DEFAULT 0,
        ovamp REAL DEFAULT 0,
        mpen REAL DEFAULT 0,
        health REAL DEFAULT 0,
        armor REAL DEFAULT 0,
        mr REAL DEFAULT 0,
        hp5 REAL DEFAULT 0,
        ms REAL DEFAULT 0,
        maps TEXT DEFAULT 'All',
        description TEXT DEFAULT '',
        last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(item_id, name)
    )
    ''')

    # æ¯”èµ›æ•°æ®è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS matches (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        match_id TEXT UNIQUE,
        patch TEXT,
        queue_type TEXT,
        rank_fk INTEGER,
        game_duration INTEGER,
        game_duration_minutes REAL,
        major_patch TEXT,
        patch_short TEXT,
        rank_category TEXT,
        uploaded_by TEXT DEFAULT 'mouxu',
        uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_analyzed BOOLEAN DEFAULT 0
    )
    ''')

    # åˆ†æç»“æœç¼“å­˜
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS analysis_cache (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        cache_key TEXT UNIQUE,
        data_type TEXT,
        data_json TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        expires_at TIMESTAMP
    )
    ''')

    conn.commit()
    conn.close()
    print(f"âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: {DB_PATH}")

# ========== æ•°æ®å¯¼å…¥å‡½æ•° ==========
def import_items_from_csv(filepath='ItemTbl.csv'):
    """å¯¼å…¥è£…å¤‡æ•°æ®"""
    try:
        if not os.path.exists(filepath):
            return {'success': False, 'error': f'æ–‡ä»¶ä¸å­˜åœ¨: {filepath}'}

        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        imported = 0
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            if content.startswith('\ufeff'):
                content = content[1:]

            reader = csv.reader(content.strip().splitlines())
            next(reader)  # è·³è¿‡æ ‡é¢˜è¡Œ

            for row in reader:
                if len(row) >= 2:
                    item_id = int(row[0]) if row[0].isdigit() else 0
                    name = row[1].strip()

                    if item_id and name:
                        cursor.execute('''
                            INSERT OR IGNORE INTO items (item_id, name)
                            VALUES (?, ?)
                        ''', (item_id, name))

                        if cursor.rowcount == 1:
                            imported += 1

        conn.commit()

        # æ›´æ–°ç»Ÿè®¡
        cursor.execute("SELECT COUNT(*) FROM items")  
        total = cursor.fetchone()[0]

        conn.close()

        return {
            'success': True,
            'imported': imported,
            'total': total,
            'message': f'æˆåŠŸå¯¼å…¥ {imported} ä»¶è£…å¤‡'
        }

    except Exception as e:
        return {'success': False, 'error': str(e)}

def import_item_stats(filepath='LOL_items_stats.csv'):
    """å¯¼å…¥è£…å¤‡è¯¦ç»†å±æ€§"""
    try:
        if not os.path.exists(filepath):
            return {'success': False, 'error': f'æ–‡ä»¶ä¸å­˜åœ¨: {filepath}'}

        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        updated = 0
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            if content.startswith('\ufeff'):
                content = content[1:]

            reader = csv.reader(content.strip().splitlines(), delimiter=';')
            headers = next(reader)

            for row in reader:
                if len(row) >= 1:
                    name = row[0].strip()
                    if not name:
                        continue

                    # è§£ææ‰€æœ‰å±æ€§
                    cost = int(row[1]) if len(row) > 1 and row[1] and row[1].isdigit() else 0
                    sell = int(row[2]) if len(row) > 2 and row[2] and row[2].isdigit() else 0

                    ad = float(row[3]) if len(row) > 3 and row[3] else 0
                    as_ = float(row[4]) if len(row) > 4 and row[4] else 0
                    crit = float(row[5]) if len(row) > 5 and row[5] else 0
                    ls = float(row[6]) if len(row) > 6 and row[6] else 0
                    apen = float(row[7]) if len(row) > 7 and row[7] else 0
                    ap = float(row[8]) if len(row) > 8 and row[8] else 0
                    ah = float(row[9]) if len(row) > 9 and row[9] else 0
                    mana = float(row[10]) if len(row) > 10 and row[10] else 0
                    mp5 = float(row[11]) if len(row) > 11 and row[11] else 0
                    hsp = float(row[12]) if len(row) > 12 and row[12] else 0
                    ovamp = float(row[13]) if len(row) > 13 and row[13] else 0
                    mpen = float(row[14]) if len(row) > 14 and row[14] else 0
                    health = float(row[15]) if len(row) > 15 and row[15] else 0
                    armor = float(row[16]) if len(row) > 16 and row[16] else 0
                    mr = float(row[17]) if len(row) > 17 and row[17] else 0
                    hp5 = float(row[18]) if len(row) > 18 and row[18] else 0
                    ms = float(row[19]) if len(row) > 19 and row[19] else 0
                    maps = row[20] if len(row) > 20 else 'All'

                    # æ›´æ–°è£…å¤‡æ•°æ®
                    cursor.execute('''
                        UPDATE items
                        SET gold_total = ?, gold_sell = ?, ad = ?, as_ = ?, crit = ?, ls = ?,
                            apen = ?, ap = ?, ah = ?, mana = ?, mp5 = ?, hsp = ?,
                            ovamp = ?, mpen = ?, health = ?, armor = ?, mr = ?,
                            hp5 = ?, ms = ?, maps = ?
                        WHERE name = ?
                    ''', (cost, sell, ad, as_, crit, ls, apen, ap, ah, mana,
                          mp5, hsp, ovamp, mpen, health, armor, mr, hp5, ms, maps, name))

                    if cursor.rowcount > 0:
                        updated += 1

        conn.commit()
        conn.close()

        return {
            'success': True,
            'updated': updated,
            'message': f'æ›´æ–°äº† {updated} ä»¶è£…å¤‡çš„å±æ€§æ•°æ®'
        }

    except Exception as e:
        return {'success': False, 'error': str(e)}

# ========== æ¯”èµ›æ•°æ®å¤„ç† ==========
def process_match_file(file_content, filename):
    """å¤„ç†ä¸Šä¼ çš„æ¯”èµ›æ•°æ®æ–‡ä»¶"""
    try:
        # æ£€æŸ¥æ–‡ä»¶ç¼–ç 
        if file_content.startswith('\ufeff'):
            file_content = file_content[1:]

        # ä½¿ç”¨pandasè¯»å–CSV
        df = pd.read_csv(io.StringIO(file_content))

        # æ£€æŸ¥å¿…è¦çš„åˆ—
        required_cols = ['MatchId', 'Patch', 'QueueType', 'RankFk', 'GameDuration']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            return {'success': False, 'error': f'ç¼ºå°‘å¿…è¦çš„åˆ—: {missing_cols}'}

        # æ¸…ç†æ•°æ®
        df = df.dropna(subset=['MatchId'])
        df['MatchId'] = df['MatchId'].astype(str).str.strip()
        df['Patch'] = df['Patch'].astype(str).str.strip()
        df['QueueType'] = df['QueueType'].astype(str).str.strip()
        df['RankFk'] = pd.to_numeric(df['RankFk'], errors='coerce').fillna(0).astype(int)
        df['GameDuration'] = pd.to_numeric(df['GameDuration'], errors='coerce').fillna(0).astype(int)

        # æ·»åŠ è®¡ç®—åˆ—
        df['GameDuration_Minutes'] = (df['GameDuration'] / 60).round(2)
        df['MajorPatch'] = df['Patch'].str.extract(r'(\d+\.\d+)')
        df['Patch_Short'] = df['Patch'].apply(lambda x: '.'.join(str(x).split('.')[:2]))

        # æ®µä½åˆ†ç±»
        def get_rank_category(rank_fk):
            rank_map = {
                0: 'æœªå®šçº§/æ™®é€š',
                1: 'é’é“œ',
                2: 'ç™½é“¶',
                3: 'é»„é‡‘',
                4: 'é“‚é‡‘',
                5: 'é’»çŸ³',
                6: 'å¤§å¸ˆ',
                7: 'å®—å¸ˆ',
                8: 'ç‹è€…'
            }
            return rank_map.get(rank_fk, f'æœªçŸ¥({rank_fk})')

        df['Rank_Category'] = df['RankFk'].apply(get_rank_category)

        # ä¿å­˜åˆ°æ•°æ®åº“
        conn = sqlite3.connect(DB_PATH)
        imported = 0
        skipped = 0

        for _, row in df.iterrows():
            try:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO matches
                    (match_id, patch, queue_type, rank_fk, game_duration,
                     game_duration_minutes, major_patch, patch_short, rank_category)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    row['MatchId'], row['Patch'], row['QueueType'],
                    row['RankFk'], row['GameDuration'], row['GameDuration_Minutes'],
                    row['MajorPatch'], row['Patch_Short'], row['Rank_Category']
                ))

                if cursor.rowcount == 1:
                    imported += 1
                else:
                    skipped += 1
            except:
                skipped += 1

        conn.commit()
        conn.close()

        # ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
        stats = {
            'filename': filename,
            'total_records': len(df),
            'imported': imported,
            'skipped': skipped,
            'success_rate': round(imported / len(df) * 100, 2) if len(df) > 0 else 0,
            'avg_duration': round(df['GameDuration_Minutes'].mean(), 2),
            'min_duration': df['GameDuration_Minutes'].min(),
            'max_duration': df['GameDuration_Minutes'].max(),
            'unique_modes': df['QueueType'].nunique(),
            'unique_patches': df['Patch_Short'].nunique(),
            'unique_ranks': df['Rank_Category'].nunique(),
            'data_preview': df.head(10).to_dict('records')
        }

        return {'success': True, 'stats': stats}

    except Exception as e:
        return {'success': False, 'error': str(e)}

# ========== æ•°æ®åˆ†æå‡½æ•° ==========
@lru_cache(maxsize=32)
def get_match_statistics():
    """è·å–æ¯”èµ›æ•°æ®ç»Ÿè®¡(å¸¦ç¼“å­˜)"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        # åŸºç¡€ç»Ÿè®¡
        cursor.execute("SELECT COUNT(*) FROM matches")
        total = cursor.fetchone()[0]

        if total == 0:
            return None

        cursor.execute("""
            SELECT
                COUNT(*) as total,
                AVG(game_duration_minutes) as avg_duration,
                MIN(game_duration_minutes) as min_duration,
                MAX(game_duration_minutes) as max_duration,
                COUNT(DISTINCT queue_type) as unique_modes,
                COUNT(DISTINCT patch_short) as unique_patches,
                COUNT(DISTINCT rank_category) as unique_ranks
            FROM matches
        """)

        row = cursor.fetchone()
        basic_stats = {
            'total': row[0],
            'avg_duration': round(row[1], 2) if row[1] else 0,
            'min_duration': row[2] if row[2] else 0,
            'max_duration': row[3] if row[3] else 0,
            'unique_modes': row[4],
            'unique_patches': row[5],
            'unique_ranks': row[6]
        }

        # æ¨¡å¼åˆ†å¸ƒ
        cursor.execute("""
            SELECT queue_type, COUNT(*) as count,
                   ROUND(AVG(game_duration_minutes), 2) as avg_duration
            FROM matches
            GROUP BY queue_type
            ORDER BY count DESC
        """)
        modes = cursor.fetchall()

        # æ®µä½åˆ†å¸ƒ
        cursor.execute("""
            SELECT rank_category, COUNT(*) as count,
                   ROUND(AVG(game_duration_minutes), 2) as avg_duration
            FROM matches
            WHERE rank_category != 'æœªçŸ¥(0)'
            GROUP BY rank_category
            ORDER BY
                CASE rank_category
                    WHEN 'ç‹è€…' THEN 1
                    WHEN 'å®—å¸ˆ' THEN 2
                    WHEN 'å¤§å¸ˆ' THEN 3
                    WHEN 'é’»çŸ³' THEN 4
                    WHEN 'é“‚é‡‘' THEN 5
                    WHEN 'é»„é‡‘' THEN 6
                    WHEN 'ç™½é“¶' THEN 7
                    WHEN 'é’é“œ' THEN 8
                    WHEN 'æœªå®šçº§/æ™®é€š' THEN 9
                    ELSE 10
                END
        """)
        ranks = cursor.fetchall()

        # ç‰ˆæœ¬è¶‹åŠ¿
        cursor.execute("""
            SELECT patch_short, COUNT(*) as count,
                   ROUND(AVG(game_duration_minutes), 2) as avg_duration
            FROM matches
            WHERE patch_short IS NOT NULL AND patch_short != ''
            GROUP BY patch_short
            ORDER BY patch_short
        """)
        versions = cursor.fetchall()

        # æ—¶é•¿åˆ†å¸ƒ
        cursor.execute("""
            SELECT
                CASE
                    WHEN game_duration_minutes < 15 THEN '0-15åˆ†é’Ÿ'
                    WHEN game_duration_minutes < 25 THEN '15-25åˆ†é’Ÿ'
                    WHEN game_duration_minutes < 35 THEN '25-35åˆ†é’Ÿ'
                    ELSE '35+åˆ†é’Ÿ'
                END as duration_range,
                COUNT(*) as count,
                ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM matches), 2) as percentage
            FROM matches
            GROUP BY duration_range
            ORDER BY
                CASE duration_range
                    WHEN '0-15åˆ†é’Ÿ' THEN 1
                    WHEN '15-25åˆ†é’Ÿ' THEN 2
                    WHEN '25-35åˆ†é’Ÿ' THEN 3
                    WHEN '35+åˆ†é’Ÿ' THEN 4
                END
        """)
        duration_dist = cursor.fetchall()

        conn.close()

        return {
            'basic': basic_stats,
            'modes': modes,
            'ranks': ranks,
            'versions': versions,
            'duration_dist': duration_dist,
            'last_updated': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }

    except Exception as e:
        print(f"ç»Ÿè®¡é”™è¯¯: {e}")
        return None

# ========== ç½‘é¡µè·¯ç”± ==========
@app.route('/')
def home():
    """é¦–é¡µ - ä¼˜åŒ–ç‰ˆ,å‡å°‘æ•°æ®åº“æŸ¥è¯¢"""
    # å¿«é€Ÿè·å–ç»Ÿè®¡ä¿¡æ¯,ä¸åˆå§‹åŒ–æ•°æ®åº“
    item_count = 0
    match_count = 0
    
    try:
        import sqlite3
        import os
        DB_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'lol_data.db')
        
        if os.path.exists(DB_PATH):
            conn = sqlite3.connect(DB_PATH, timeout=5)
            cursor = conn.cursor()
            
            try:
                cursor.execute("SELECT COUNT(*) FROM items")  # # Temporary comment\n                item_count = cursor.fetchone()[0] or 0
            except:
                item_count = 0
                
            try:
                cursor.execute("SELECT COUNT(*) FROM matches")
                match_count = cursor.fetchone()[0] or 0
            except:
                match_count = 0
                
            conn.close()
    except:
        pass  # é™é»˜å¤„ç†é”™è¯¯
    
    return render_template('index.html',
                         item_count=item_count,
                         match_count=match_count,
                         username='mouxu',
                         site_url='mouxu.pythonanywhere.com')

@app.route('/items')
def items_page():
    """è£…å¤‡é¡µé¢"""
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM items
            WHERE gold_total > 0
            ORDER BY gold_total DESC
            LIMIT 100
        """)
        items = cursor.fetchall()
        conn.close()

        return render_template('items.html', items=items)
    except Exception as e:
        return render_template('error.html', error=str(e))

# @app.route('/match_analysis')
# def match_analysis():
    """æ¯”èµ›æ•°æ®åˆ†æé¡µé¢"""
    stats = get_match_statistics()
    return render_template('match_analysis.html',
                         stats=stats,
                         has_data=stats is not None)

@app.route('/match_results')
def match_results():
    """åˆ†æç»“æœé¡µé¢"""
    analysis = get_match_statistics()
    if not analysis:
        return render_template('no_data.html')

    return render_template('match_results.html', analysis=analysis)


@app.route('/about')

def about():
    """å…³äºé¡µé¢"""
    return render_template('about.html')
@app.route('/analysis')
def analysis():
    """æ•°æ®åˆ†æé¡µé¢"""
    return render_template('analysis.html')
@app.route('/upload')
def upload_page():
    """æ–‡ä»¶ä¸Šä¼ é¡µé¢"""
    return render_template('upload.html')

# ========== APIæ¥å£ ==========
@app.route('/api/import/items', methods=['POST'])
def api_import_items():
    """å¯¼å…¥è£…å¤‡æ•°æ®"""
    try:
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not os.path.exists('ItemTbl.csv'):
            return jsonify({'success': False, 'error': 'ItemTbl.csv æ–‡ä»¶ä¸å­˜åœ¨'})

        result1 = import_items_from_csv('ItemTbl.csv')

        # å¦‚æœæœ‰è¯¦ç»†å±æ€§æ–‡ä»¶,ä¹Ÿå¯¼å…¥
        if os.path.exists('LOL_items_stats.csv'):
            result2 = import_item_stats('LOL_items_stats.csv')
        else:
            result2 = {'success': True, 'updated': 0, 'message': 'è·³è¿‡è¯¦ç»†å±æ€§å¯¼å…¥'}

        return jsonify({
            'success': result1['success'] and result2['success'],
            'basic_items': result1,
            'detailed_stats': result2,
            'total_affected': result1.get('imported', 0) + result2.get('updated', 0)
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/match/upload', methods=['POST'])
def api_match_upload():
    """ä¸Šä¼ æ¯”èµ›æ•°æ®"""
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'})

    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'})

    if not file.filename.endswith('.csv'):
        return jsonify({'success': False, 'error': 'åªæ”¯æŒCSVæ ¼å¼æ–‡ä»¶'})

    try:
        # è¯»å–æ–‡ä»¶å†…å®¹
        file_content = file.read().decode('utf-8')
        result = process_match_file(file_content, file.filename)

        return jsonify(result)

    except UnicodeDecodeError:
        try:
            # å°è¯•å…¶ä»–ç¼–ç 
            file.seek(0)
            file_content = file.read().decode('gbk')
            result = process_match_file(file_content, file.filename)
            return jsonify(result)
        except:
            return jsonify({'success': False, 'error': 'æ–‡ä»¶ç¼–ç ä¸æ”¯æŒ,è¯·ä½¿ç”¨UTF-8ç¼–ç '})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/match/stats')
def api_match_stats():
    """è·å–æ¯”èµ›ç»Ÿè®¡"""
    stats = get_match_statistics()
    if stats:
        return jsonify({'success': True, 'data': stats})
    return jsonify({'success': False, 'error': 'æ²¡æœ‰æ¯”èµ›æ•°æ®'})

@app.route('/api/match/export')
def api_match_export():
    """å¯¼å‡ºæ¯”èµ›æ•°æ®"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT match_id, patch, queue_type, rank_fk,
                   game_duration, game_duration_minutes, rank_category,
                   uploaded_at
            FROM matches
            ORDER BY uploaded_at DESC
        """)
        data = cursor.fetchall()
        conn.close()

        if not data:
            return jsonify({'success': False, 'error': 'æ²¡æœ‰æ•°æ®å¯å¯¼å‡º'}), 404

        # åˆ›å»ºCSV
        output = io.StringIO()
        writer = csv.writer(output)

        writer.writerow(['MatchId', 'Patch', 'QueueType', 'RankFk',
                         'GameDuration(ç§’)', 'GameDuration(åˆ†é’Ÿ)',
                         'RankCategory', 'UploadedAt'])

        for row in data:
            writer.writerow(row)

        output.seek(0)
        response = app.response_class(
            output.getvalue(),
            mimetype='text/csv',
            headers={
                'Content-Disposition': f'attachment; filename=match_data_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
            }
        )

        return response

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/match/clear', methods=['POST'])
def api_clear_matches():
    """æ¸…é™¤æ‰€æœ‰æ¯”èµ›æ•°æ®"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        cursor.execute("SELECT COUNT(*) FROM matches")
        count = cursor.fetchone()[0]

        cursor.execute("DELETE FROM matches")
        cursor.execute("DELETE FROM analysis_cache")

        conn.commit()
        conn.close()

        return jsonify({
            'success': True,
            'cleared': count,
            'message': f'å·²æ¸…é™¤ {count} æ¡æ¯”èµ›è®°å½•'
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/items/list')
def api_items_list():
    """è·å–è£…å¤‡åˆ—è¡¨"""
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # è·å–æŸ¥è¯¢å‚æ•°
        limit = request.args.get('limit', default=50, type=int)
        offset = request.args.get('offset', default=0, type=int)
        sort_by = request.args.get('sort_by', default='gold_total')
        order = request.args.get('order', default='DESC')

        valid_sort_fields = ['name', 'gold_total', 'ad', 'ap', 'health', 'armor', 'mr']
        if sort_by not in valid_sort_fields:
            sort_by = 'gold_total'

        order = 'DESC' if order.upper() == 'DESC' else 'ASC'

        cursor.execute(f"""
#             SELECT * FROM items  # 
            ORDER BY {sort_by} {order}
            LIMIT ? OFFSET ?
        """, (limit, offset))

        items = [dict(row) for row in cursor.fetchall()]

        cursor.execute("SELECT COUNT(*) FROM items")  
        total = cursor.fetchone()[0]

        conn.close()

        return jsonify({
            'success': True,
            'count': len(items),
            'total': total,
            'items': items,
            'pagination': {
                'limit': limit,
                'offset': offset,
                'has_more': offset + len(items) < total
            }
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# ========== è¾…åŠ©è·¯ç”± ==========
@app.route('/health')
def health_check():
    """å¥åº·æ£€æŸ¥"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'database': os.path.exists(DB_PATH),
        'items_count': get_item_count(),
        'matches_count': get_match_count()
    })

def get_item_count():
    """è·å–è£…å¤‡æ•°é‡"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM items")  
        count = cursor.fetchone()[0]
        conn.close()
        return count
    except:
        return 0

def get_match_count():
    """è·å–æ¯”èµ›æ•°é‡"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM matches")
        count = cursor.fetchone()[0]
        conn.close()
        return count
    except:
        return 0

@app.route('/static/<path:filename>')
def serve_static(filename):
    return send_from_directory('static', filename)

# ========== é”™è¯¯å¤„ç† ==========
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_error(e):
    return render_template('500.html'), 500

# ========== å¯åŠ¨åº”ç”¨ ==========

@app.route('/api/stats.json')
def api_stats():
    """æä¾›ç»Ÿè®¡æ•°æ®çš„JSON API"""
    import json
    import os
    from datetime import datetime
    
    try:
        # ä»CSVæ–‡ä»¶è®¡ç®—çœŸå®æ•°æ®
        import pandas as pd
        items_df = pd.read_csv('ItemTbl.csv')
        matches_df = pd.read_csv('MatchTbl.csv')
        
        stats = {
            "itemCount": len(items_df),  # è£…å¤‡æ€»æ•°
            "matchCount": len(matches_df),  # æ¯”èµ›è®°å½•æ€»æ•°
            "totalSize": f"{(os.path.getsize('ItemTbl.csv') + os.path.getsize('MatchTbl.csv')) / 1024:.1f} KB"
        }
    except Exception as e:
        # å¦‚æœè¯»æ–‡ä»¶å¤±è´¥,è¿”å›æ¨¡æ‹Ÿæ•°æ®
        stats = {
            "itemCount": 258,
            "matchCount": 1250,
            "totalSize": "45.2 KB"
        }
    
    return json.dumps(stats, ensure_ascii=False)


if __name__ == '__main__':
    # åˆå§‹åŒ–æ•°æ®åº“
    init_database()

    print("=" * 60)
    print("ğŸš€ è‹±é›„è”ç›Ÿè£…å¤‡ä¸æ•°æ®åˆ†æç½‘ç«™ - mouxu")
    print("=" * 60)
    print(f"ğŸ“ é¡¹ç›®ç›®å½•: {BASE_DIR}")
    print(f"ğŸ—„ï¸  æ•°æ®åº“è·¯å¾„: {DB_PATH}")
    print(f"ğŸ‘¤ ç”¨æˆ·å: mouxu")
    print(f"ğŸŒ è®¿é—®åœ°å€: http://localhost:5000")
    print("=" * 60)
    print("ğŸ“Š åŠŸèƒ½æ¨¡å—:")
    print("   1. è£…å¤‡æ•°æ®æŸ¥è¯¢ä¸å¯¼å…¥")
    print("   2. æ¯”èµ›æ•°æ®åˆ†æä¸å¯è§†åŒ–")
    print("   3. CSVæ–‡ä»¶ä¸Šä¼ ä¸å¤„ç†")
    print("   4. æ•°æ®å¯¼å‡ºåŠŸèƒ½")
    print("=" * 60)

    app.run(host='0.0.0.0', port=5000, debug=True)


@app.route('/api/items/count')
def api_items_count():
    """è·å–è£…å¤‡æ€»æ•°API"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM items")
        count = cursor.fetchone()[0]
        conn.close()
        return jsonify({'count': count})
    except Exception as e:
        return jsonify({'count': 0, 'error': str(e)}), 500

# ===================== æ¯”èµ›æ•°æ®åˆ†æåŠŸèƒ½ =====================

@app.route('/match_analysis', methods=['GET'])
def match_analysis():
    """æ¯”èµ›æ•°æ®åˆ†æä¸»é¡µé¢"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # è·å–æ¯”èµ›ç»Ÿè®¡æ•°æ®
        cursor.execute("""
            SELECT 
                COUNT(*) as total_matches,
                AVG(game_duration) as avg_duration,
                SUM(CASE WHEN winner = 1 THEN 1 ELSE 0 END) as blue_wins,
                SUM(CASE WHEN winner = 2 THEN 1 ELSE 0 END) as red_wins
            FROM matches
        """)
        stats = cursor.fetchone()
        
        # è·å–æœ€è¿‘æ¯”èµ›
        cursor.execute("""
            SELECT match_id, game_version, game_duration, winner, blue_team_kills, red_team_kills
            FROM matches 
            ORDER BY uploaded_at DESC 
            LIMIT 5
        """)
        recent_matches = cursor.fetchall()
        
        # è·å–çƒ­é—¨è‹±é›„
        cursor.execute("""
            SELECT champion_name, COUNT(*) as play_count, 
                   AVG(kills) as avg_kills, AVG(deaths) as avg_deaths, AVG(assists) as avg_assists
            FROM match_players 
            WHERE champion_name IS NOT NULL 
            GROUP BY champion_name 
            ORDER BY play_count DESC 
            LIMIT 10
        """)
        popular_champions = cursor.fetchall()
        
        conn.close()
        
        return render_template('match_analysis.html',
                             total_matches=stats[0] if stats else 0,
                             avg_duration=int(stats[1]) if stats and stats[1] else 0,
                             blue_wins=stats[2] if stats else 0,
                             red_wins=stats[3] if stats else 0,
                             recent_matches=recent_matches,
                             popular_champions=popular_champions)
                             
    except Exception as e:
        print(f"Error in match_analysis: {e}")
        return render_template('match_analysis.html', error=str(e))

@app.route('/api/analysis/win_rate', methods=['GET'])
def api_win_rate_analysis():
    """èƒœç‡åˆ†æAPI"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # æŒ‰æ¸¸æˆæ—¶é•¿åˆ†æèƒœç‡
        cursor.execute("""
            SELECT 
                CASE 
                    WHEN game_duration < 1500 THEN 'çŸ­å¯¹å±€(<25min)'
                    WHEN game_duration BETWEEN 1500 AND 2100 THEN 'æ ‡å‡†å¯¹å±€(25-35min)'
                    ELSE 'é•¿å¯¹å±€(>35min)'
                END as duration_range,
                COUNT(*) as total_matches,
                SUM(CASE WHEN winner = 1 THEN 1 ELSE 0 END) as blue_wins,
                SUM(CASE WHEN winner = 2 THEN 1 ELSE 0 END) as red_wins
            FROM matches
            WHERE game_duration > 0
            GROUP BY duration_range
            ORDER BY game_duration
        """)
        
        result = []
        for row in cursor.fetchall():
            total = row[1]
            blue_rate = round(row[2] / total * 100, 1) if total > 0 else 0
            red_rate = round(row[3] / total * 100, 1) if total > 0 else 0
            
            result.append({
                'duration_range': row[0],
                'total_matches': total,
                'blue_win_rate': blue_rate,
                'red_win_rate': red_rate
            })
        
        conn.close()
        return jsonify({'success': True, 'data': result})
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/analysis/champion_stats', methods=['GET'])
def api_champion_stats():
    """è‹±é›„ç»Ÿè®¡æ•°æ®API"""
    try:
        champion = request.args.get('champion', '')
        limit = int(request.args.get('limit', 20))
        
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        if champion:
            cursor.execute("""
                SELECT 
                    champion_name,
                    COUNT(*) as total_games,
                    ROUND(AVG(kills), 1) as avg_kills,
                    ROUND(AVG(deaths), 1) as avg_deaths,
                    ROUND(AVG(assists), 1) as avg_assists,
                    ROUND(AVG(kills + assists) * 1.0 / NULLIF(AVG(deaths), 0), 2) as avg_kda,
                    ROUND(AVG(gold_earned)) as avg_gold,
                    SUM(CASE WHEN team_id = winner THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as win_rate
                FROM match_players mp
                JOIN matches m ON mp.match_id = m.match_id
                WHERE champion_name = ?
                GROUP BY champion_name
            """, (champion,))
        else:
            cursor.execute("""
                SELECT 
                    champion_name,
                    COUNT(*) as total_games,
                    ROUND(AVG(kills), 1) as avg_kills,
                    ROUND(AVG(deaths), 1) as avg_deaths,
                    ROUND(AVG(assists), 1) as avg_assists,
                    ROUND(AVG(kills + assists) * 1.0 / NULLIF(AVG(deaths), 0), 2) as avg_kda,
                    ROUND(AVG(gold_earned)) as avg_gold,
                    SUM(CASE WHEN mp.team_id = m.winner THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as win_rate
                FROM match_players mp
                JOIN matches m ON mp.match_id = m.match_id
                WHERE champion_name IS NOT NULL
                GROUP BY champion_name
                HAVING COUNT(*) >= 3
                ORDER BY total_games DESC
                LIMIT ?
            """, (limit,))
        
        columns = ['champion', 'games', 'kills', 'deaths', 'assists', 'kda', 'gold', 'win_rate']
        result = []
        for row in cursor.fetchall():
            result.append(dict(zip(columns, row)))
        
        conn.close()
        return jsonify({'success': True, 'data': result})
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/analysis/team_composition', methods=['GET'])
def api_team_composition():
    """é˜µå®¹åˆ†æAPI"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # åˆ†æå¸¸è§é˜µå®¹ç»„åˆ
        cursor.execute("""
            WITH team_comps AS (
                SELECT 
                    m.match_id,
                    m.winner,
                    GROUP_CONCAT(mp.champion_name ORDER BY mp.champion_name) as team_champions
                FROM matches m
                JOIN match_players mp ON m.match_id = mp.match_id
                WHERE mp.team_id = 100  -- è“é˜Ÿ
                GROUP BY m.match_id, m.winner
            )
            SELECT 
                team_champions,
                COUNT(*) as frequency,
                SUM(CASE WHEN winner = 1 THEN 1 ELSE 0 END) as wins,
                ROUND(SUM(CASE WHEN winner = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 1) as win_rate
            FROM team_comps
            GROUP BY team_champions
            HAVING COUNT(*) >= 2
            ORDER BY frequency DESC
            LIMIT 10
        """)
        
        result = []
        for row in cursor.fetchall():
            result.append({
                'composition': row[0],
                'frequency': row[1],
                'wins': row[2],
                'win_rate': row[3]
            })
        
        conn.close()
        return jsonify({'success': True, 'data': result})
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/upload_match', methods=['GET', 'POST'])
def upload_match():
    """ä¸Šä¼ æ¯”èµ›æ•°æ®"""
    if request.method == 'POST':
        try:
            if 'file' not in request.files:
                return render_template('upload.html', error='è¯·é€‰æ‹©æ–‡ä»¶')
            
            file = request.files['file']
            if file.filename == '':
                return render_template('upload.html', error='è¯·é€‰æ‹©æ–‡ä»¶')
            
            if file and file.filename.endswith('.csv'):
                # ä¿å­˜æ–‡ä»¶
                filename = secure_filename(file.filename)
                filepath = os.path.join('uploads', filename)
                os.makedirs('uploads', exist_ok=True)
                file.save(filepath)
                
                # è§£æCSVå¹¶å¯¼å…¥æ•°æ®åº“
                result = import_match_data(filepath)
                
                return render_template('upload.html', 
                                     success=True, 
                                     message=f'æˆåŠŸå¯¼å…¥ {result["imported"]} æ¡æ¯”èµ›æ•°æ®')
            else:
                return render_template('upload.html', error='åªæ”¯æŒCSVæ–‡ä»¶')
                
        except Exception as e:
            return render_template('upload.html', error=f'ä¸Šä¼ å¤±è´¥: {str(e)}')
    
    return render_template('upload.html')

def import_match_data(filepath):
    """å¯¼å…¥æ¯”èµ›æ•°æ®CSV"""
    import csv
    import uuid
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    imported = 0
    with open(filepath, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        
        for row in reader:
            try:
                # ç”Ÿæˆå”¯ä¸€æ¯”èµ›ID
                match_id = row.get('match_id', f'UPLOAD_{uuid.uuid4().hex[:10]}')
                
                # æ’å…¥æ¯”èµ›æ•°æ®
                cursor.execute("""
                    INSERT OR IGNORE INTO matches (
                        match_id, game_version, game_duration, winner,
                        blue_team_kills, red_team_kills,
                        blue_team_gold, red_team_gold
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    match_id,
                    row.get('game_version', '14.24'),
                    int(row.get('game_duration', 1800)),
                    int(row.get('winner', 1)),
                    int(row.get('blue_kills', 0)),
                    int(row.get('red_kills', 0)),
                    int(row.get('blue_gold', 0)),
                    int(row.get('red_gold', 0))
                ))
                
                # æ’å…¥ç©å®¶æ•°æ®ï¼ˆç®€åŒ–ç‰ˆï¼‰
                for team in ['blue', 'red']:
                    for i in range(1, 6):
                        champion_key = f'{team}_champ{i}'
                        kills_key = f'{team}_kills{i}'
                        deaths_key = f'{team}_deaths{i}'
                        assists_key = f'{team}_assists{i}'
                        
                        if champion_key in row and row[champion_key]:
                            cursor.execute("""
                                INSERT INTO match_players (
                                    match_id, summoner_name, champion_name, team_id,
                                    kills, deaths, assists
                                ) VALUES (?, ?, ?, ?, ?, ?, ?)
                            """, (
                                match_id,
                                f'Player_{team}_{i}',
                                row[champion_key],
                                100 if team == 'blue' else 200,
                                int(row.get(kills_key, 0)),
                                int(row.get(deaths_key, 0)),
                                int(row.get(assists_key, 0))
                            ))
                
                imported += 1
                
            except Exception as e:
                print(f"å¯¼å…¥é”™è¯¯: {e}")
                continue
    
    conn.commit()
    conn.close()
    
    return {'imported': imported}
