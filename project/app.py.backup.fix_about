# åœ¨ app.py çš„é¡¶éƒ¨æ·»åŠ ï¼ˆåœ¨ç°æœ‰importè¯­å¥åé¢ï¼‰
import sys
import os

# ========== æ€§èƒ½ä¼˜åŒ– ==========
# ç¦ç”¨è°ƒè¯•æ¨¡å¼
import flask
flask.cli.show_server_banner = lambda *args: None

# å‡å°‘æ—¥å¿—è¾“å‡º
import logging
logging.getLogger('werkzeug').setLevel(logging.ERROR)

# é™åˆ¶æ•°æ®åº“è¿æ¥
import sqlite3
import atexit

# è¿æ¥æ± ç®¡ç†
_db_connections = {}

def get_db_connection():
    """è·å–æ•°æ®åº“è¿æ¥ï¼ˆå¸¦è¿æ¥æ± ï¼‰"""
    import threading
    thread_id = threading.get_ident()

    if thread_id not in _db_connections:
        _db_connections[thread_id] = sqlite3.connect(
            DB_PATH,
            timeout=10,
            check_same_thread=False
        )
        _db_connections[thread_id].row_factory = sqlite3.Row

    return _db_connections[thread_id]

def close_db_connections():
    """å…³é—­æ‰€æœ‰æ•°æ®åº“è¿æ¥"""
    for conn in _db_connections.values():
        try:
            conn.close()
        except:
            pass
    _db_connections.clear()

atexit.register(close_db_connections)

# ========== åŸæ¥çš„ä»£ç ç»§ç»­... ==========
from flask import Flask, render_template, request, jsonify, send_file, send_from_directory
import sqlite3
import os
import csv
import json
import time
import pandas as pd
import numpy as np
from datetime import datetime
import io
import hashlib
from functools import lru_cache

# ========== åº”ç”¨é…ç½® ==========
app = Flask(__name__, static_folder="static", template_folder="templates")
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB
app.config['SECRET_KEY'] = 'mouxu-lol-site-2024-secret'

# PythonAnywhereè·¯å¾„é…ç½®
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, 'instance', 'lol_data.db')
UPLOAD_FOLDER = os.path.join(BASE_DIR, 'uploads')

# ç¡®ä¿ç›®å½•å­˜åœ¨
os.makedirs(os.path.join(BASE_DIR, 'instance'), exist_ok=True)
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# ========== æ•°æ®åº“åˆå§‹åŒ– ==========
def init_database():
    """åˆå§‹åŒ–æ•°æ®åº“"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # è£…å¤‡è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        item_id INTEGER,
        name TEXT NOT NULL,
        gold_total INTEGER DEFAULT 0,
        gold_sell INTEGER DEFAULT 0,
        ad REAL DEFAULT 0,
        as_ REAL DEFAULT 0,
        crit REAL DEFAULT 0,
        ls REAL DEFAULT 0,
        apen REAL DEFAULT 0,
        ap REAL DEFAULT 0,
        ah REAL DEFAULT 0,
        mana REAL DEFAULT 0,
        mp5 REAL DEFAULT 0,
        hsp REAL DEFAULT 0,
        ovamp REAL DEFAULT 0,
        mpen REAL DEFAULT 0,
        health REAL DEFAULT 0,
        armor REAL DEFAULT 0,
        mr REAL DEFAULT 0,
        hp5 REAL DEFAULT 0,
        ms REAL DEFAULT 0,
        maps TEXT DEFAULT 'All',
        description TEXT DEFAULT '',
        last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(item_id, name)
    )
    ''')

    # æ¯”èµ›æ•°æ®è¡¨
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS matches (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        match_id TEXT UNIQUE,
        patch TEXT,
        queue_type TEXT,
        rank_fk INTEGER,
        game_duration INTEGER,
        game_duration_minutes REAL,
        major_patch TEXT,
        patch_short TEXT,
        rank_category TEXT,
        uploaded_by TEXT DEFAULT 'mouxu',
        uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_analyzed BOOLEAN DEFAULT 0
    )
    ''')

    # åˆ†æç»“æœç¼“å­˜
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS analysis_cache (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        cache_key TEXT UNIQUE,
        data_type TEXT,
        data_json TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        expires_at TIMESTAMP
    )
    ''')

    conn.commit()
    conn.close()
    print(f"âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: {DB_PATH}")

# ========== æ•°æ®å¯¼å…¥å‡½æ•° ==========
def import_items_from_csv(filepath='ItemTbl.csv'):
    """å¯¼å…¥è£…å¤‡æ•°æ®"""
    try:
        if not os.path.exists(filepath):
            return {'success': False, 'error': f'æ–‡ä»¶ä¸å­˜åœ¨: {filepath}'}

        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        imported = 0
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            if content.startswith('\ufeff'):
                content = content[1:]

            reader = csv.reader(content.strip().splitlines())
            next(reader)  # è·³è¿‡æ ‡é¢˜è¡Œ

            for row in reader:
                if len(row) >= 2:
                    item_id = int(row[0]) if row[0].isdigit() else 0
                    name = row[1].strip()

                    if item_id and name:
                        cursor.execute('''
                            INSERT OR IGNORE INTO items (item_id, name)
                            VALUES (?, ?)
                        ''', (item_id, name))

                        if cursor.rowcount == 1:
                            imported += 1

        conn.commit()

        # æ›´æ–°ç»Ÿè®¡
        cursor.execute("SELECT COUNT(*) FROM items")
        total = cursor.fetchone()[0]

        conn.close()

        return {
            'success': True,
            'imported': imported,
            'total': total,
            'message': f'æˆåŠŸå¯¼å…¥ {imported} ä»¶è£…å¤‡'
        }

    except Exception as e:
        return {'success': False, 'error': str(e)}

def import_item_stats(filepath='LOL_items_stats.csv'):
    """å¯¼å…¥è£…å¤‡è¯¦ç»†å±æ€§"""
    try:
        if not os.path.exists(filepath):
            return {'success': False, 'error': f'æ–‡ä»¶ä¸å­˜åœ¨: {filepath}'}

        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        updated = 0
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            if content.startswith('\ufeff'):
                content = content[1:]

            reader = csv.reader(content.strip().splitlines(), delimiter=';')
            headers = next(reader)

            for row in reader:
                if len(row) >= 1:
                    name = row[0].strip()
                    if not name:
                        continue

                    # è§£ææ‰€æœ‰å±æ€§
                    cost = int(row[1]) if len(row) > 1 and row[1] and row[1].isdigit() else 0
                    sell = int(row[2]) if len(row) > 2 and row[2] and row[2].isdigit() else 0

                    ad = float(row[3]) if len(row) > 3 and row[3] else 0
                    as_ = float(row[4]) if len(row) > 4 and row[4] else 0
                    crit = float(row[5]) if len(row) > 5 and row[5] else 0
                    ls = float(row[6]) if len(row) > 6 and row[6] else 0
                    apen = float(row[7]) if len(row) > 7 and row[7] else 0
                    ap = float(row[8]) if len(row) > 8 and row[8] else 0
                    ah = float(row[9]) if len(row) > 9 and row[9] else 0
                    mana = float(row[10]) if len(row) > 10 and row[10] else 0
                    mp5 = float(row[11]) if len(row) > 11 and row[11] else 0
                    hsp = float(row[12]) if len(row) > 12 and row[12] else 0
                    ovamp = float(row[13]) if len(row) > 13 and row[13] else 0
                    mpen = float(row[14]) if len(row) > 14 and row[14] else 0
                    health = float(row[15]) if len(row) > 15 and row[15] else 0
                    armor = float(row[16]) if len(row) > 16 and row[16] else 0
                    mr = float(row[17]) if len(row) > 17 and row[17] else 0
                    hp5 = float(row[18]) if len(row) > 18 and row[18] else 0
                    ms = float(row[19]) if len(row) > 19 and row[19] else 0
                    maps = row[20] if len(row) > 20 else 'All'

                    # æ›´æ–°è£…å¤‡æ•°æ®
                    cursor.execute('''
                        UPDATE items
                        SET gold_total = ?, gold_sell = ?, ad = ?, as_ = ?, crit = ?, ls = ?,
                            apen = ?, ap = ?, ah = ?, mana = ?, mp5 = ?, hsp = ?,
                            ovamp = ?, mpen = ?, health = ?, armor = ?, mr = ?,
                            hp5 = ?, ms = ?, maps = ?
                        WHERE name = ?
                    ''', (cost, sell, ad, as_, crit, ls, apen, ap, ah, mana,
                          mp5, hsp, ovamp, mpen, health, armor, mr, hp5, ms, maps, name))

                    if cursor.rowcount > 0:
                        updated += 1

        conn.commit()
        conn.close()

        return {
            'success': True,
            'updated': updated,
            'message': f'æ›´æ–°äº† {updated} ä»¶è£…å¤‡çš„å±æ€§æ•°æ®'
        }

    except Exception as e:
        return {'success': False, 'error': str(e)}

# ========== æ¯”èµ›æ•°æ®å¤„ç† ==========
def process_match_file(file_content, filename):
    """å¤„ç†ä¸Šä¼ çš„æ¯”èµ›æ•°æ®æ–‡ä»¶"""
    try:
        # æ£€æŸ¥æ–‡ä»¶ç¼–ç 
        if file_content.startswith('\ufeff'):
            file_content = file_content[1:]

        # ä½¿ç”¨pandasè¯»å–CSV
        df = pd.read_csv(io.StringIO(file_content))

        # æ£€æŸ¥å¿…è¦çš„åˆ—
        required_cols = ['MatchId', 'Patch', 'QueueType', 'RankFk', 'GameDuration']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            return {'success': False, 'error': f'ç¼ºå°‘å¿…è¦çš„åˆ—: {missing_cols}'}

        # æ¸…ç†æ•°æ®
        df = df.dropna(subset=['MatchId'])
        df['MatchId'] = df['MatchId'].astype(str).str.strip()
        df['Patch'] = df['Patch'].astype(str).str.strip()
        df['QueueType'] = df['QueueType'].astype(str).str.strip()
        df['RankFk'] = pd.to_numeric(df['RankFk'], errors='coerce').fillna(0).astype(int)
        df['GameDuration'] = pd.to_numeric(df['GameDuration'], errors='coerce').fillna(0).astype(int)

        # æ·»åŠ è®¡ç®—åˆ—
        df['GameDuration_Minutes'] = (df['GameDuration'] / 60).round(2)
        df['MajorPatch'] = df['Patch'].str.extract(r'(\d+\.\d+)')
        df['Patch_Short'] = df['Patch'].apply(lambda x: '.'.join(str(x).split('.')[:2]))

        # æ®µä½åˆ†ç±»
        def get_rank_category(rank_fk):
            rank_map = {
                0: 'æœªå®šçº§/æ™®é€š',
                1: 'é’é“œ',
                2: 'ç™½é“¶',
                3: 'é»„é‡‘',
                4: 'é“‚é‡‘',
                5: 'é’»çŸ³',
                6: 'å¤§å¸ˆ',
                7: 'å®—å¸ˆ',
                8: 'ç‹è€…'
            }
            return rank_map.get(rank_fk, f'æœªçŸ¥({rank_fk})')

        df['Rank_Category'] = df['RankFk'].apply(get_rank_category)

        # ä¿å­˜åˆ°æ•°æ®åº“
        conn = sqlite3.connect(DB_PATH)
        imported = 0
        skipped = 0

        for _, row in df.iterrows():
            try:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR IGNORE INTO matches
                    (match_id, patch, queue_type, rank_fk, game_duration,
                     game_duration_minutes, major_patch, patch_short, rank_category)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    row['MatchId'], row['Patch'], row['QueueType'],
                    row['RankFk'], row['GameDuration'], row['GameDuration_Minutes'],
                    row['MajorPatch'], row['Patch_Short'], row['Rank_Category']
                ))

                if cursor.rowcount == 1:
                    imported += 1
                else:
                    skipped += 1
            except:
                skipped += 1

        conn.commit()
        conn.close()

        # ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
        stats = {
            'filename': filename,
            'total_records': len(df),
            'imported': imported,
            'skipped': skipped,
            'success_rate': round(imported / len(df) * 100, 2) if len(df) > 0 else 0,
            'avg_duration': round(df['GameDuration_Minutes'].mean(), 2),
            'min_duration': df['GameDuration_Minutes'].min(),
            'max_duration': df['GameDuration_Minutes'].max(),
            'unique_modes': df['QueueType'].nunique(),
            'unique_patches': df['Patch_Short'].nunique(),
            'unique_ranks': df['Rank_Category'].nunique(),
            'data_preview': df.head(10).to_dict('records')
        }

        return {'success': True, 'stats': stats}

    except Exception as e:
        return {'success': False, 'error': str(e)}

# ========== æ•°æ®åˆ†æå‡½æ•° ==========
@lru_cache(maxsize=32)
def get_match_statistics():
    """è·å–æ¯”èµ›æ•°æ®ç»Ÿè®¡ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        # åŸºç¡€ç»Ÿè®¡
        cursor.execute("SELECT COUNT(*) FROM matches")
        total = cursor.fetchone()[0]

        if total == 0:
            return None

        cursor.execute("""
            SELECT
                COUNT(*) as total,
                AVG(game_duration_minutes) as avg_duration,
                MIN(game_duration_minutes) as min_duration,
                MAX(game_duration_minutes) as max_duration,
                COUNT(DISTINCT queue_type) as unique_modes,
                COUNT(DISTINCT patch_short) as unique_patches,
                COUNT(DISTINCT rank_category) as unique_ranks
            FROM matches
        """)

        row = cursor.fetchone()
        basic_stats = {
            'total': row[0],
            'avg_duration': round(row[1], 2) if row[1] else 0,
            'min_duration': row[2] if row[2] else 0,
            'max_duration': row[3] if row[3] else 0,
            'unique_modes': row[4],
            'unique_patches': row[5],
            'unique_ranks': row[6]
        }

        # æ¨¡å¼åˆ†å¸ƒ
        cursor.execute("""
            SELECT queue_type, COUNT(*) as count,
                   ROUND(AVG(game_duration_minutes), 2) as avg_duration
            FROM matches
            GROUP BY queue_type
            ORDER BY count DESC
        """)
        modes = cursor.fetchall()

        # æ®µä½åˆ†å¸ƒ
        cursor.execute("""
            SELECT rank_category, COUNT(*) as count,
                   ROUND(AVG(game_duration_minutes), 2) as avg_duration
            FROM matches
            WHERE rank_category != 'æœªçŸ¥(0)'
            GROUP BY rank_category
            ORDER BY
                CASE rank_category
                    WHEN 'ç‹è€…' THEN 1
                    WHEN 'å®—å¸ˆ' THEN 2
                    WHEN 'å¤§å¸ˆ' THEN 3
                    WHEN 'é’»çŸ³' THEN 4
                    WHEN 'é“‚é‡‘' THEN 5
                    WHEN 'é»„é‡‘' THEN 6
                    WHEN 'ç™½é“¶' THEN 7
                    WHEN 'é’é“œ' THEN 8
                    WHEN 'æœªå®šçº§/æ™®é€š' THEN 9
                    ELSE 10
                END
        """)
        ranks = cursor.fetchall()

        # ç‰ˆæœ¬è¶‹åŠ¿
        cursor.execute("""
            SELECT patch_short, COUNT(*) as count,
                   ROUND(AVG(game_duration_minutes), 2) as avg_duration
            FROM matches
            WHERE patch_short IS NOT NULL AND patch_short != ''
            GROUP BY patch_short
            ORDER BY patch_short
        """)
        versions = cursor.fetchall()

        # æ—¶é•¿åˆ†å¸ƒ
        cursor.execute("""
            SELECT
                CASE
                    WHEN game_duration_minutes < 15 THEN '0-15åˆ†é’Ÿ'
                    WHEN game_duration_minutes < 25 THEN '15-25åˆ†é’Ÿ'
                    WHEN game_duration_minutes < 35 THEN '25-35åˆ†é’Ÿ'
                    ELSE '35+åˆ†é’Ÿ'
                END as duration_range,
                COUNT(*) as count,
                ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM matches), 2) as percentage
            FROM matches
            GROUP BY duration_range
            ORDER BY
                CASE duration_range
                    WHEN '0-15åˆ†é’Ÿ' THEN 1
                    WHEN '15-25åˆ†é’Ÿ' THEN 2
                    WHEN '25-35åˆ†é’Ÿ' THEN 3
                    WHEN '35+åˆ†é’Ÿ' THEN 4
                END
        """)
        duration_dist = cursor.fetchall()

        conn.close()

        return {
            'basic': basic_stats,
            'modes': modes,
            'ranks': ranks,
            'versions': versions,
            'duration_dist': duration_dist,
            'last_updated': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }

    except Exception as e:
        print(f"ç»Ÿè®¡é”™è¯¯: {e}")
        return None

# ========== ç½‘é¡µè·¯ç”± ==========
@app.route('/')
def home():
    """é¦–é¡µ - ä¼˜åŒ–ç‰ˆï¼Œå‡å°‘æ•°æ®åº“æŸ¥è¯¢"""
    # å¿«é€Ÿè·å–ç»Ÿè®¡ä¿¡æ¯ï¼Œä¸åˆå§‹åŒ–æ•°æ®åº“
    item_count = 0
    match_count = 0
    
    try:
        import sqlite3
        import os
        DB_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance', 'lol_data.db')
        
        if os.path.exists(DB_PATH):
            conn = sqlite3.connect(DB_PATH, timeout=5)
            cursor = conn.cursor()
            
            try:
                cursor.execute("SELECT COUNT(*) FROM items")
                item_count = cursor.fetchone()[0] or 0
            except:
                item_count = 0
                
            try:
                cursor.execute("SELECT COUNT(*) FROM matches")
                match_count = cursor.fetchone()[0] or 0
            except:
                match_count = 0
                
            conn.close()
    except:
        pass  # é™é»˜å¤„ç†é”™è¯¯
    
    return render_template('index.html',
                         item_count=item_count,
                         match_count=match_count,
                         username='mouxu',
                         site_url='mouxu.pythonanywhere.com')

@app.route('/items')
def items_page():
    """è£…å¤‡é¡µé¢"""
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM items
            WHERE gold_total > 0
            ORDER BY gold_total DESC
            LIMIT 100
        """)
        items = cursor.fetchall()
        conn.close()

        return render_template('items.html', items=items)
    except Exception as e:
        return render_template('error.html', error=str(e))

@app.route('/match_analysis')
def match_analysis():
    """æ¯”èµ›æ•°æ®åˆ†æé¡µé¢"""
    stats = get_match_statistics()
    return render_template('match_analysis.html',
                         stats=stats,
                         has_data=stats is not None)

@app.route('/match_results')
def match_results():
    """åˆ†æç»“æœé¡µé¢"""
    analysis = get_match_statistics()
    if not analysis:
        return render_template('no_data.html')

    return render_template('match_results.html', analysis=analysis)


@app.route('/about')
def about():
    """å…³äºé¡µé¢"""
    return render_template('about.html')

@app.route('/analysis')
def analysis():
    """æ•°æ®åˆ†æé¡µé¢"""
    return render_template('analysis.html')
@app.route('/upload')
def upload_page():
    """æ–‡ä»¶ä¸Šä¼ é¡µé¢"""
    return render_template('upload.html')

# ========== APIæ¥å£ ==========
@app.route('/api/import/items', methods=['POST'])
def api_import_items():
    """å¯¼å…¥è£…å¤‡æ•°æ®"""
    try:
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not os.path.exists('ItemTbl.csv'):
            return jsonify({'success': False, 'error': 'ItemTbl.csv æ–‡ä»¶ä¸å­˜åœ¨'})

        result1 = import_items_from_csv('ItemTbl.csv')

        # å¦‚æœæœ‰è¯¦ç»†å±æ€§æ–‡ä»¶ï¼Œä¹Ÿå¯¼å…¥
        if os.path.exists('LOL_items_stats.csv'):
            result2 = import_item_stats('LOL_items_stats.csv')
        else:
            result2 = {'success': True, 'updated': 0, 'message': 'è·³è¿‡è¯¦ç»†å±æ€§å¯¼å…¥'}

        return jsonify({
            'success': result1['success'] and result2['success'],
            'basic_items': result1,
            'detailed_stats': result2,
            'total_affected': result1.get('imported', 0) + result2.get('updated', 0)
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/match/upload', methods=['POST'])
def api_match_upload():
    """ä¸Šä¼ æ¯”èµ›æ•°æ®"""
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'})

    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'})

    if not file.filename.endswith('.csv'):
        return jsonify({'success': False, 'error': 'åªæ”¯æŒCSVæ ¼å¼æ–‡ä»¶'})

    try:
        # è¯»å–æ–‡ä»¶å†…å®¹
        file_content = file.read().decode('utf-8')
        result = process_match_file(file_content, file.filename)

        return jsonify(result)

    except UnicodeDecodeError:
        try:
            # å°è¯•å…¶ä»–ç¼–ç 
            file.seek(0)
            file_content = file.read().decode('gbk')
            result = process_match_file(file_content, file.filename)
            return jsonify(result)
        except:
            return jsonify({'success': False, 'error': 'æ–‡ä»¶ç¼–ç ä¸æ”¯æŒï¼Œè¯·ä½¿ç”¨UTF-8ç¼–ç '})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/match/stats')
def api_match_stats():
    """è·å–æ¯”èµ›ç»Ÿè®¡"""
    stats = get_match_statistics()
    if stats:
        return jsonify({'success': True, 'data': stats})
    return jsonify({'success': False, 'error': 'æ²¡æœ‰æ¯”èµ›æ•°æ®'})

@app.route('/api/match/export')
def api_match_export():
    """å¯¼å‡ºæ¯”èµ›æ•°æ®"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT match_id, patch, queue_type, rank_fk,
                   game_duration, game_duration_minutes, rank_category,
                   uploaded_at
            FROM matches
            ORDER BY uploaded_at DESC
        """)
        data = cursor.fetchall()
        conn.close()

        if not data:
            return jsonify({'success': False, 'error': 'æ²¡æœ‰æ•°æ®å¯å¯¼å‡º'}), 404

        # åˆ›å»ºCSV
        output = io.StringIO()
        writer = csv.writer(output)

        writer.writerow(['MatchId', 'Patch', 'QueueType', 'RankFk',
                         'GameDuration(ç§’)', 'GameDuration(åˆ†é’Ÿ)',
                         'RankCategory', 'UploadedAt'])

        for row in data:
            writer.writerow(row)

        output.seek(0)
        response = app.response_class(
            output.getvalue(),
            mimetype='text/csv',
            headers={
                'Content-Disposition': f'attachment; filename=match_data_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
            }
        )

        return response

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/match/clear', methods=['POST'])
def api_clear_matches():
    """æ¸…é™¤æ‰€æœ‰æ¯”èµ›æ•°æ®"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()

        cursor.execute("SELECT COUNT(*) FROM matches")
        count = cursor.fetchone()[0]

        cursor.execute("DELETE FROM matches")
        cursor.execute("DELETE FROM analysis_cache")

        conn.commit()
        conn.close()

        return jsonify({
            'success': True,
            'cleared': count,
            'message': f'å·²æ¸…é™¤ {count} æ¡æ¯”èµ›è®°å½•'
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/items/list')
def api_items_list():
    """è·å–è£…å¤‡åˆ—è¡¨"""
    try:
        conn = sqlite3.connect(DB_PATH)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # è·å–æŸ¥è¯¢å‚æ•°
        limit = request.args.get('limit', default=50, type=int)
        offset = request.args.get('offset', default=0, type=int)
        sort_by = request.args.get('sort_by', default='gold_total')
        order = request.args.get('order', default='DESC')

        valid_sort_fields = ['name', 'gold_total', 'ad', 'ap', 'health', 'armor', 'mr']
        if sort_by not in valid_sort_fields:
            sort_by = 'gold_total'

        order = 'DESC' if order.upper() == 'DESC' else 'ASC'

        cursor.execute(f"""
            SELECT * FROM items
            ORDER BY {sort_by} {order}
            LIMIT ? OFFSET ?
        """, (limit, offset))

        items = [dict(row) for row in cursor.fetchall()]

        cursor.execute("SELECT COUNT(*) FROM items")
        total = cursor.fetchone()[0]

        conn.close()

        return jsonify({
            'success': True,
            'count': len(items),
            'total': total,
            'items': items,
            'pagination': {
                'limit': limit,
                'offset': offset,
                'has_more': offset + len(items) < total
            }
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# ========== è¾…åŠ©è·¯ç”± ==========
@app.route('/health')
def health_check():
    """å¥åº·æ£€æŸ¥"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'database': os.path.exists(DB_PATH),
        'items_count': get_item_count(),
        'matches_count': get_match_count()
    })

def get_item_count():
    """è·å–è£…å¤‡æ•°é‡"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM items")
        count = cursor.fetchone()[0]
        conn.close()
        return count
    except:
        return 0

def get_match_count():
    """è·å–æ¯”èµ›æ•°é‡"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM matches")
        count = cursor.fetchone()[0]
        conn.close()
        return count
    except:
        return 0

@app.route('/static/<path:filename>')
def serve_static(filename):
    return send_from_directory('static', filename)

# ========== é”™è¯¯å¤„ç† ==========
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_error(e):
    return render_template('500.html'), 500

# ========== å¯åŠ¨åº”ç”¨ ==========

@app.route('/api/stats.json')
def api_stats():
    """æä¾›ç»Ÿè®¡æ•°æ®çš„JSON API"""
    import json
    import os
    from datetime import datetime
    
    try:
        # ä»CSVæ–‡ä»¶è®¡ç®—çœŸå®æ•°æ®
        import pandas as pd
        items_df = pd.read_csv('ItemTbl.csv')
        matches_df = pd.read_csv('MatchTbl.csv')
        
        stats = {
            "itemCount": len(items_df),  # è£…å¤‡æ€»æ•°
            "matchCount": len(matches_df),  # æ¯”èµ›è®°å½•æ€»æ•°
            "totalSize": f"{(os.path.getsize('ItemTbl.csv') + os.path.getsize('MatchTbl.csv')) / 1024:.1f} KB"
        }
    except Exception as e:
        # å¦‚æœè¯»æ–‡ä»¶å¤±è´¥ï¼Œè¿”å›æ¨¡æ‹Ÿæ•°æ®
        stats = {
            "itemCount": 258,
            "matchCount": 1250,
            "totalSize": "45.2 KB"
        }
    
    return json.dumps(stats, ensure_ascii=False)


if __name__ == '__main__':
    # åˆå§‹åŒ–æ•°æ®åº“
    init_database()

    print("=" * 60)
    print("ğŸš€ è‹±é›„è”ç›Ÿè£…å¤‡ä¸æ•°æ®åˆ†æç½‘ç«™ - mouxu")
    print("=" * 60)
    print(f"ğŸ“ é¡¹ç›®ç›®å½•: {BASE_DIR}")
    print(f"ğŸ—„ï¸  æ•°æ®åº“è·¯å¾„: {DB_PATH}")
    print(f"ğŸ‘¤ ç”¨æˆ·å: mouxu")
    print(f"ğŸŒ è®¿é—®åœ°å€: http://localhost:5000")
    print("=" * 60)
    print("ğŸ“Š åŠŸèƒ½æ¨¡å—:")
    print("   1. è£…å¤‡æ•°æ®æŸ¥è¯¢ä¸å¯¼å…¥")
    print("   2. æ¯”èµ›æ•°æ®åˆ†æä¸å¯è§†åŒ–")
    print("   3. CSVæ–‡ä»¶ä¸Šä¼ ä¸å¤„ç†")
    print("   4. æ•°æ®å¯¼å‡ºåŠŸèƒ½")
    print("=" * 60)

    app.run(host='0.0.0.0', port=5000, debug=True)

